<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="ManWithBear"/><link rel="canonical" href="https://manwithbear.com/articles/2021-09-03-fighting-trees-pet-projject-series-1"/><meta name="twitter:url" content="https://manwithbear.com/articles/2021-09-03-fighting-trees-pet-projject-series-1"/><meta name="og:url" content="https://manwithbear.com/articles/2021-09-03-fighting-trees-pet-projject-series-1"/><title>Fighting trees - Pet project series - 1/x | ManWithBear</title><meta name="twitter:title" content="Fighting trees - Pet project series - 1/x | ManWithBear"/><meta name="og:title" content="Fighting trees - Pet project series - 1/x | ManWithBear"/><meta name="description" content="Developer notes around iOS / Swift / Programming"/><meta name="twitter:description" content="Developer notes around iOS / Swift / Programming"/><meta name="og:description" content="Developer notes around iOS / Swift / Programming"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/css/splash.css" type="text/css"/><link rel="stylesheet" href="/css/theme.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to ManWithBear"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">ManWithBear</a><nav><ul><li><a href="/">Home</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Fighting trees - Pet project series - 1/x</h1><p>Wow, the first week is behind us. That was fast.</p><p>Let's quickly go over the first week:</p><p>Right after publishing the article I pull Playground and start <s>blasting</s> coding.</p><h2>Identifier</h2><p>One thing I love in Swift are small wrapper types.</p><p>For example <code>Identifier</code> wrapper</p><pre><code><span class="keyword">struct</span> Identifier&lt;T, Raw: <span class="type">Hashable</span>&gt;: <span class="type">RawRepresentable</span>, <span class="type">Equatable</span>, <span class="type">Hashable</span> {
    <span class="keyword">typealias</span> RawValue = <span class="type">Raw</span>
    <span class="keyword">let</span> rawValue: <span class="type">Raw</span>
    <span class="keyword">init</span>(rawValue: <span class="type">RawValue</span>) {
        <span class="keyword">self</span>.<span class="property">rawValue</span> = rawValue
    }
}

<span class="keyword">class</span> MagicPony {
    <span class="keyword">typealias</span> ID = <span class="type">Identifier</span>&lt;<span class="type">MagicPony</span>, <span class="type">UUID</span>&gt;
    <span class="keyword">let</span> id = <span class="type">ID</span>(rawValue: <span class="type">UUID</span>())
}
</code></pre><p>By wrapping your string / uuid ids into type specific wrappers you let swift type system prevent mistakes like putting <code>User.ID</code> into <code>Admin.ID</code> instead of relying on developers.</p><p>Side note: I found out that Swift has built-in <code>Identifiable</code> and <code>ObjectIdentifier</code>.<br><code>ObjectIdentifier</code> applies to classes only and does not persist between app runs. So it makes it unusable for me right now.</p><h2>Licenses</h2><p>For a longer period of time I was almost always ignoring licenses of libraries and software that I use / write. This time before uploading repo I decided to get a better picture of the licensing world. And hell it's complicated! Kudos to Em Lazer-Walker for her article: <a href="https://blog.lazerwalker.com/cortado/2015/07/05/open-source-licenses.html">Picking an OSS license for your iOS app</a> After hours of reading the BSD vs GPL holy wars, that was a breath of fresh air.</p><p>Right now I do not expect someone else to contribute to the project and honestly, even use it at all. So I decided to go with GPLv3 as it's not AppStore friendly (not like it will prevent someone from releasing it under their name, but I would be in the right, sadge). In future I may change the license of the project or release part of it under a different license like MIT or similar. If you are interested in using something from the project, do not hesitate to reach out.</p><p>Okey, okey, back to interesting stuff - programming.</p><h2>SPM</h2><p>For this project I want to stick with Swift Package Manager as much as possible. That's where the first disappointment awaited me. Although SPM allows you to create executables, it still cannot produce iOS apps. After a little research I stumble on this thread: <a href="https://forums.swift.org/t/use-spm-to-build-ios-target/25436">Use SPM to build iOS target - Using Swift - Swift Forums</a></p><p>tl;dr;</p><p><strong>Swift ≠ iOS Development</strong></p><p>Although it would be cool to write apps using only SPM, building an iOS app requires a lot of additional steps, like copying resources / signing / etc, that are not related to Swift in any way. And it makes total sense.</p><h2>Overengineering is our bread and butter</h2><p>Remember when I said "no overengineering"? Keep it simple?<br>Easier said than done!</p><p>I just found myself writing <code>TopologicalOrderSequence</code> after understanding that <code>TopologicalIterator</code> is not enough for me.<br>Do I really need it? <strong>No.</strong><br>Should I do it right now? <strong>No.</strong><br>Is this the best solution for my problem? <strong>Most likely no.</strong><br>But here I am.</p><p>It sounds interesting. It sounds complicated. It sounds "engineery" and "cool".<br>And I think it's a problem with developers in general.<br>No one gonna brag to friends / colleagues about one more function they wrote, but wrap it in fancy words and uncommon technologies and now we’re talking!</p><h2>Complexity of init</h2><p>While writing <code>Engine</code> I start preprocessing data and recipes in <code>init</code> for simpler future calculations. Now looking at it, I would say it's a bad idea.<br>A lot of developers expect <code>init</code> to be an <code>O(1)</code> operation, which is not always the case. How many times have I heard: "I'm just creating one object here, it's fine", to later find out that the program spends seconds (!!) in this <code>init</code>.<br>It may sound like pre-emptive optimizations, and honestly in 99% it is, but I consider it good practise and part of consistency.</p><h2>Recursion vs loops</h2><p>During implementation of <code>add(ingredient:...)</code> I notice that I unintentionally prefer non-recursive algorithms over recursive ones. A possible reason is without having limits on the amount of ingredients, we cannot guarantee that recursion will fit in the available stack. Again, it's a case of "better safe than sorry".<br>Most compilers are smart enough to apply tail-recursion optimizations, so in most cases it's not something you should worry about. But not in my case.</p><h2>First "real" issue</h2><p>Recipes planning went very well until I stumbled on recipes that produce not 1 thing but multiple (remember 4 nails from 1 iron ore?).<br>Right now if we have a recipe: <em>2X -&gt; 1Y</em>, when the user adds 1Y in inventory, the app will add virtual 2X as well, because it's X that already "used" for Y.<br>If the recipe is reverted: <em>1X -&gt; 2Y</em>, when user adds 1Y in inventory, it's not enough for full recipe so virtual X's are not added.<br>So far so good.<br>But what if the user adds 1Y again? If we look at the transaction outside of context, it's exactly as before, no X to add. With context we have 1Y from before, that gives us 2Y in total and 1 virtual X to give.</p><p>To solve this calculation issue we could go 2 ways:</p><ol><li>Split user inventory between "real" and "virtual".<br/> Whenever the user adds an item to inventory, we update "real" inventory, flush "virtual" inventory and recalculate it from "real".<br/> I don't really like this approach, because it feels "too heavy" to recalculate from inventory on each update instead of doing smart half tree recalculations.</li></ol><ol start="2"><li>Instead of recalculation inventory, recalculate requirements (<code>needed - whats_in_inventory</code>).<br/> This could lead us to a situation when the user has more subproducts that are needed and can be really confusing.</li></ol><p>Because of how hard it is to properly communicate to the user what's going on in the 2nd case (even I myself do not fully understand it yet), I decided to go with the 1st approach.</p><h2>What to expect next?</h2><p>Currently I don't like how <code>ingredient.id</code> is used everywhere and probably would do something with that next week.</p><p>If you missed the first post of this series, I got you: <a href="https://manwithbear.com/articles/2021-08-27-starting-pet-project-series-0/">Starting Pet project series 0/x | ManWithBear</a></p><p>See ya!</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/theproject">theproject</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>